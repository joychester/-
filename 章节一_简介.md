## 1. 简介  

> 
> - *写小说有三个准则。很不幸，没人知道它们是什么。——萨默塞特·毛姆(Somerset Maugham)*  
> - *如果你不知道你要去哪里，你千万要小心，因为你可能永远也到不了那里。——尤吉·贝拉(Yogi Berra)*  
> - *我之所以能看的更远，是因为我站在了巨人的肩膀上。——伯尔纳铎(Bernard of Chartres)*  
> - *莎士比亚因为懂的不多而写出了更美的诗歌；米尔顿...因为知道太多反而毁了他的诗歌。——A.N.怀特海德(A.N. Whitehead)*    
>  

设计一个计算机系统与设计一个算法截然不同，一般来说设计一个计算机系统： 
- 其对外接口(或需求)更加复杂，模棱两可且易变  
- 其内部会由更多的子系统或模块组成，因此会有更多的内部接口  
- 很难衡量其是否是更优秀的设计  

设计者一开始往往会有种力不从心，盲人摸象的感觉，不确定某一种选择会不会限制或阻碍到其他的选择，甚至可能会影响到整个系统的容量和性能。也许现实中就不存在一个最优的整体解决方案, 甚至部分也没有*。 这篇文章希望强调的一点是，做设计时，尽可能使内部系统之间泾渭分明，从而避免采用糟糕的解决方案。 

我曾经设计和构建了许多计算机系统，有些成功了，有些却没有。我也曾使用和研究过其他人设计的系统，也是喜忧参半。从这些亲身经历中，我整理出来一些设计优秀系统时通用的设计建议和准则。其中大部分是资深设计者的经验之谈，然而俗话说的好，“人们更能接受善意的提醒而不是被说教，这一点往往会被忽略”。这里会讲到一些普世的原则(比如抽象和模块)，也会用一些反面教材帮助我们从不同的角度去理解怎么做才是对的。

我将这些原则通过三个经典的问题(What? How? When, Who?)从三个维度，用一句话简短的话来概括: __*STEADY by AID with ART*__:
> 
> - *What? 目标 STEADY：Simple(简单明了)，Timely(及时的)，Efficient(高效的)，Adaptable(灵活的)，Dependable(可靠的)，Yummy(有品味的)*  
> - *How? 对策 by AID：Approximate(效仿)，Incremental(迭代)，Divide&Conquer(分而治之)*  
> - *When，who? 流程 with ART：Architecture(架构)，Automate(自动化)，Review(审查)，Techniques(技巧)，Test(测试)*     
>  

做系统设计时，人们常常会考虑诸多建议，但其中最为重要的几条建议如下：
> - 简单明了 (Keep it simple)
> - 撰写文档 (Write a spec)
> - 模块化设计 (Design with independent modules)
> - 追求高效 (Exploit the ABCs of effiency)
> - 理解状态的本质 (Treat state as both being and becoming)
> - 利用最终一致性模型实现数据本地化 (Use eventual consistency to keep data local)

以上这些仅仅是建议而已。它们不是科幻小说(但也有一些是例外，魔力无穷)，并不保证万无一失，药到病除，一层不变，也不是经过精确演算得到的科学公式，更没有经过所有牛人们的一致认可。要学会去辨别剔除那些对你没有帮助，甚至适得其反的条目。

这篇文章会以一堆反义词开头(简单的与复杂的，指令式与声明式，等等)，来帮助你认清设计系统时的优先顺序和组织结构。第二章主要讲诉一些原则，比如：抽象，说明文档，编码，模块化以及拥有自己主见的重要性。第三章里，首先会在每一节把实现每一个目标的方法与技巧描述清楚，其次会介绍一个比较通用的迭代方法。截止到目前，“高效的”这一次提到的最多，其次是“可靠的”，主要是因为，“局部性原则”和“并发”可以归为“高效的”话题，而“冗余”则属于“可靠性”的范畴，这三架马车(locality, concurrency, redundancy)在当今的系统设计中至关重要。在第四章里，我会简短的讨论一下非技术领域中的流程话题，然后在第五章中会讨论每一组反义词。在整个讨论过程中，你会看到各种毫无违和感的口号，也会看到各种吐槽的名言警句。